#include <algorithm>
#include <typeinfo>
#include "rsyncxx/cmd.hpp"

namespace rsync {
    static unsigned _nbytes[] = { 1, 2, 4, 8 };
    uint8_t *
    make_param(uint8_t *cur, uint64_t param, uint8_t paramtype)
    {
        unsigned nbytes = _nbytes[paramtype];
        for (unsigned idx = 0; idx < nbytes; ++idx) {
            *cur++ = (uint8_t)param;
            param >>= 8;
        }
        return cur;
    }

    const uint8_t cstatus_cmd = 0;
    const uint8_t cstatus_cmd_params = 1;
    const uint8_t cstatus_cmd_body = 2;
    buf_t *
    cmd_t::step(bool &done, buf_t *bobj, bool lastbuf, node_t *joint)
    {
        while (bobj->buf0 < bobj->buf1)
            switch (_status) {
            case cstatus_cmd:
                bobj = _parse_cmd(bobj, lastbuf, joint);
                break;
            case cstatus_cmd_params:
                bobj = _parse_cmd_params(bobj, lastbuf, joint);
                break;
            default:
                bobj = runstream(bobj, lastbuf, joint);
                break;
            }
        if (_pbuf == _pbufcur && lastbuf && bobj->buf0 == bobj->buf1) {
            if (!_kc_exit()); // graph violation deteced.
            done = true;
        } else {
            if (_kc_exit()); // graph violation detected.
        }
#if 0
        fprintf(stderr, "%s: done = %s, lastbuf = %s\n", typeid(*this).name(),
                bool2str(done), bool2str(lastbuf));
#endif
        return bobj;
        // do not call node_t::step because not any outputs can be
        // generated by cmd_t.
        //return node_t::step(done, bobj, lastbuf, joint);
    }
    buf_t *
    cmd_t::_parse_cmd(buf_t *bobj, bool lastbuf, node_t *joint)
    {
        _prevcmd = _cmd;
        assert(bobj->buf0 < bobj->buf1);
        _cmd = *bobj->buf0++;
        if (!_kc_next()) { // graph violatoin detected.
        }
        _pbufcur = _pbuf;
        if (_suite->paramsize(_cmd) > 0) {
            _status = cstatus_cmd_params;
            return bobj;
        }
        _param1 = _suite->specs[_cmd].immed;
#if 0
        fprintf(stderr, "kind: %u, cmd: %u, %u, %u\n",
                (unsigned)_kind(_cmd), (unsigned)_cmd, (unsigned)_param1, (unsigned)_param2);
#endif
        return runcmd(bobj, lastbuf, joint);
    }
    buf_t *
    cmd_t::_parse_cmd_params(buf_t *bobj, bool lastbuf, node_t *joint)
    {
        const uint8_t *cur;
        uint8_t szparam = _suite->paramsize(_cmd);
        ptrdiff_t remains = (ptrdiff_t)szparam - (_pbufcur - _pbuf);
        ptrdiff_t nbytes = std::min(bobj->buf1 - bobj->buf0, remains);
        _pbufcur = bobj->read(_pbufcur, nbytes);
        if (_pbufcur < _pbuf + szparam) {
            _status =  cstatus_cmd_params;
            return bobj;
        }
        cur = _parse_param(_pbuf, _param1, _suite->specs[_cmd].szparam1);
        cur = _parse_param(cur, _param2, _suite->specs[_cmd].szparam2);
#if 0
        fprintf(stderr, "kind: %u, cmd: %u, %u, %u\n",
                (unsigned)_kind(_cmd), (unsigned)_cmd, (unsigned)_param1, (unsigned)_param2);
#endif
        return runcmd(bobj, lastbuf, joint);
    }
    const uint8_t *
    cmd_t::_parse_param(const uint8_t *cur, uint64_t &param, uint8_t szparam) const
    {
        param = 0;
        for (uint8_t idx = 0; idx < szparam; ++idx)
            param |= ((uint64_t)*cur++) << idx * 8;
        return cur;
    }
}
